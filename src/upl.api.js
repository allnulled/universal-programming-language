/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Language: peg$parseLanguage },
        peg$startRuleFunction  = peg$parseLanguage,

        peg$c0 = function(shebang, token1, header, token2, body, token3) { return {type:"Language",header,body,footer:get_metrics(),seed:text()}},
        peg$c1 = "#!",
        peg$c2 = peg$literalExpectation("#!", false),
        peg$c3 = function(declarations) { return { type: "Preblock", declarations, script: text().length, location: minify_location(location()) } },
        peg$c4 = function(functions) { return pack_declarations(functions) },
        peg$c5 = "=",
        peg$c6 = peg$literalExpectation("=", false),
        peg$c7 = function(token1, shortcut, token2, name) { return declare_function_shortcut(shortcut, name) },
        peg$c8 = function(sentences) { return sentences },
        peg$c9 = function(sentence) { return sentence },
        peg$c10 = peg$anyExpectation(),
        peg$c11 = " ",
        peg$c12 = peg$literalExpectation(" ", false),
        peg$c13 = "\t",
        peg$c14 = peg$literalExpectation("\t", false),
        peg$c15 = "\r\n",
        peg$c16 = peg$literalExpectation("\r\n", false),
        peg$c17 = "\r",
        peg$c18 = peg$literalExpectation("\r", false),
        peg$c19 = "\n",
        peg$c20 = peg$literalExpectation("\n", false),
        peg$c21 = "comment{{",
        peg$c22 = peg$literalExpectation("comment{{", false),
        peg$c23 = "}}",
        peg$c24 = peg$literalExpectation("}}", false),
        peg$c25 = function(token1, comment, token3) { return comment },
        peg$c26 = function(origin, extended_by) { return extended_by.length ? Object.assign(origin, { extended_by }) : origin },
        peg$c27 = ".",
        peg$c28 = peg$literalExpectation(".", false),
        peg$c29 = function(token1, access) { return { type: "Access_by_dot_appendix", access, script: text().length, location: minify_location(location()) } },
        peg$c30 = function(access) { return { type: "Access_by_accessor_appendix", access, script: text().length, location: minify_location(location()) } },
        peg$c31 = function(parameters) { return parameters; },
        peg$c32 = function(operator, pipe) { return { type: "Pipe_appendix", operator, pipe, script: text().length, location: minify_location(location()) } },
        peg$c33 = function(token1, op, token2) { return text().trim() },
        peg$c34 = function(first, others) { return [first].concat(others || []) },
        peg$c35 = function(token1, word) { return word },
        peg$c36 = "|[",
        peg$c37 = peg$literalExpectation("|[", false),
        peg$c38 = "]",
        peg$c39 = peg$literalExpectation("]", false),
        peg$c40 = "|@",
        peg$c41 = peg$literalExpectation("|@", false),
        peg$c42 = "|=",
        peg$c43 = peg$literalExpectation("|=", false),
        peg$c44 = "|",
        peg$c45 = peg$literalExpectation("|", false),
        peg$c46 = function(op) { return text() },
        peg$c47 = function(chars) { return chars.join("") },
        peg$c48 = function(neg, ch) { return ch },
        peg$c49 = "\\]",
        peg$c50 = peg$literalExpectation("\\]", false),
        peg$c51 = function() { return "]" },
        peg$c52 = "[",
        peg$c53 = peg$literalExpectation("[", false),
        peg$c54 = function(token1, properties, token2) { return { type: "Object", supertype: "Generative", properties: properties || [], script: text().length, location: minify_location(location()) } },
        peg$c55 = "object{",
        peg$c56 = peg$literalExpectation("object{", false),
        peg$c57 = "}",
        peg$c58 = peg$literalExpectation("}", false),
        peg$c59 = function(token1, key, token2, val) { return { key, val } },
        peg$c60 = function(token1, prop) { return prop },
        peg$c61 = function(token1, generative, token2) { return generative },
        peg$c62 = "@",
        peg$c63 = peg$literalExpectation("@", false),
        peg$c64 = function(token1, name) { return { type: "Variable", supertype: "Generative", name, script: text().length, location: minify_location(location()) } },
        peg$c65 = function(base, atoms) { return { type: "Covalent_molecule", supertype: "Generative", base, atoms, script: text().length, location: minify_location(location()) } },
        peg$c66 = function(atoms) { return simplify_molecule_type({ type: "Functional_molecule", atoms, script: text().length, location: minify_location(location()) }) },
        peg$c67 = function(name, parameters) { return { type: "Functional_atom", name, parameters, script: text().length, location: minify_location(location()) } },
        peg$c68 = function(atom_id) { return add_functional_atom_mention(atom_id) },
        peg$c69 = "#",
        peg$c70 = peg$literalExpectation("#", false),
        peg$c71 = function(token1, name) { return name },
        peg$c72 = function(token1, aliased) { return { type: "Function_name_by_shortcut", id: resolve_function_shortcut(aliased), aliased, script: text().length, location: minify_location(location()) } },
        peg$c73 = function(name) { return { type: "Function_name_by_word", id: name, aliased: null, script: text().length, location: minify_location(location()) } },
        peg$c74 = function(first, others) { return [first].concat(others || []).join(" ") },
        peg$c75 = "{",
        peg$c76 = peg$literalExpectation("{", false),
        peg$c77 = function(token1, parameters, token2) { return { type: "Function_call_appendix_for_list_parameter", list: parameters || [], script: text().length, location: minify_location(location()) } },
        peg$c78 = "!",
        peg$c79 = peg$literalExpectation("!", false),
        peg$c80 = function(token1) { return { type: "Function_call_appendix_for_empty_parameter", script: text().length, location: minify_location(location()) } },
        peg$c81 = function(parameter) { return parameter },
        peg$c82 = /^[A-Za-z\xC1\xC9\xCD\xD3\xDA\xE1\xE9\xED\xF3\xFA\xC0\xC8\xCC\xD2\xD9\xE0\xE8\xEC\xF2\xF9\xC4\xCB\xCF\xD6\xDC\xE4\xEB\xEF\xF6\xFC\xC2\xCA\xCE\xD4\xDB\xE2\xEA\xEE\xF4\xFB\xF1\xB7\xE7'\-_$]/,
        peg$c83 = peg$classExpectation([["A", "Z"], ["a", "z"], "\xC1", "\xC9", "\xCD", "\xD3", "\xDA", "\xE1", "\xE9", "\xED", "\xF3", "\xFA", "\xC0", "\xC8", "\xCC", "\xD2", "\xD9", "\xE0", "\xE8", "\xEC", "\xF2", "\xF9", "\xC4", "\xCB", "\xCF", "\xD6", "\xDC", "\xE4", "\xEB", "\xEF", "\xF6", "\xFC", "\xC2", "\xCA", "\xCE", "\xD4", "\xDB", "\xE2", "\xEA", "\xEE", "\xF4", "\xFB", "\xF1", "\xB7", "\xE7", "'", "-", "_", "$"], false, false),
        peg$c84 = /^[A-Za-z0-9\xC1\xC9\xCD\xD3\xDA\xE1\xE9\xED\xF3\xFA\xC0\xC8\xCC\xD2\xD9\xE0\xE8\xEC\xF2\xF9\xC4\xCB\xCF\xD6\xDC\xE4\xEB\xEF\xF6\xFC\xC2\xCA\xCE\xD4\xDB\xE2\xEA\xEE\xF4\xFB\xF1\xB7\xE7'\-_$]/,
        peg$c85 = peg$classExpectation([["A", "Z"], ["a", "z"], ["0", "9"], "\xC1", "\xC9", "\xCD", "\xD3", "\xDA", "\xE1", "\xE9", "\xED", "\xF3", "\xFA", "\xC0", "\xC8", "\xCC", "\xD2", "\xD9", "\xE0", "\xE8", "\xEC", "\xF2", "\xF9", "\xC4", "\xCB", "\xCF", "\xD6", "\xDC", "\xE4", "\xEB", "\xEF", "\xF6", "\xFC", "\xC2", "\xCA", "\xCE", "\xD4", "\xDB", "\xE2", "\xEA", "\xEE", "\xF4", "\xFB", "\xF1", "\xB7", "\xE7", "'", "-", "_", "$"], false, false),
        peg$c86 = function() { return text() },
        peg$c87 = function(n) { return { type: "Number", supertype: "Generative", value: n, script: text().length, location: minify_location(location()) } },
        peg$c88 = "-",
        peg$c89 = peg$literalExpectation("-", false),
        peg$c90 = /^[0-9]/,
        peg$c91 = peg$classExpectation([["0", "9"]], false, false),
        peg$c92 = function(polarity, num, dec) { return dec ? parseFloat(text()) : parseInt(text()) },
        peg$c93 = function(t) { return { type: "Text", supertype: "Generative", contents: t, script: text().length, location: minify_location(location()) } },
        peg$c94 = function(token1, contents, token2) { return contents },
        peg$c95 = "\"",
        peg$c96 = peg$literalExpectation("\"", false),
        peg$c97 = "\\\"",
        peg$c98 = peg$literalExpectation("\\\"", false),
        peg$c99 = function() { return '"' },
        peg$c100 = "\\}}",
        peg$c101 = peg$literalExpectation("\\}}", false),
        peg$c102 = function() { return /*{{*/ "}}" },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseLanguage() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseShebang_for_linux();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parse_();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parse_();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePreblock();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parse_();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parse_();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseBlock();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parse_();
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$parse_();
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c0(s1, s2, s3, s4, s5, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseShebang_for_linux() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c1) {
        s1 = peg$c1;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNo_EOL();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePreblock() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseDeclare_function_shortcuts();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c3(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDeclare_function_shortcuts() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseDeclare_function_shortcut();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseDeclare_function_shortcut();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c4(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseDeclare_function_shortcut() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_name_by_shortcut_without_resolving();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parse_();
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseFunction_name_by_word_without_packing();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c7(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseBlock() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseFull_sentence();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseFull_sentence();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFull_sentence() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseGenerative_extended();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOS();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseEOS() {
      var s0;

      s0 = peg$parse___();
      if (s0 === peg$FAILED) {
        s0 = peg$parseEOF();
      }

      return s0;
    }

    function peg$parseEOF() {
      var s0, s1;

      s0 = peg$currPos;
      peg$silentFails++;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      peg$silentFails--;
      if (s1 === peg$FAILED) {
        s0 = void 0;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parse_() {
      var s0;

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = peg$parse___();
        if (s0 === peg$FAILED) {
          s0 = peg$parseComment_group();
        }
      }

      return s0;
    }

    function peg$parse__() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c11;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s0 = peg$c13;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
      }

      return s0;
    }

    function peg$parse___() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c15) {
        s0 = peg$c15;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c17;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c19;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
        }
      }

      return s0;
    }

    function peg$parseComment_group() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c21) {
        s1 = peg$c21;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseContents_between_double_curly_brackets();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c23) {
            s3 = peg$c23;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c24); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseGenerative_extended() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseGenerative_pure();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsePipe_appendix();
        if (s3 === peg$FAILED) {
          s3 = peg$parseAccess_appendix();
          if (s3 === peg$FAILED) {
            s3 = peg$parseCall_appendix();
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsePipe_appendix();
          if (s3 === peg$FAILED) {
            s3 = peg$parseAccess_appendix();
            if (s3 === peg$FAILED) {
              s3 = peg$parseCall_appendix();
            }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAccess_appendix() {
      var s0;

      s0 = peg$parseAccess_by_dot_appendix();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAccess_by_accessor_appendix();
      }

      return s0;
    }

    function peg$parseAccess_by_dot_appendix() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWord();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseAccess_by_accessor_appendix() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseGenerative_between_square_bracket();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c30(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseCall_appendix() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseFunction_call_appendix();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c31(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsePipe_appendix() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsePipe_operator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseGenerative_pure();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePipe_operator() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseValid_pipe_operators();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parse_();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c33(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseChained_word() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseWord();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseChained_word_continuation();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseChained_word_continuation();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseChained_word_continuation() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parse_();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parse_();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c27;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWord();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c35(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseValid_pipe_operators() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c36) {
        s2 = peg$c36;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseGenerative_extended();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s4 = peg$c38;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c40) {
          s2 = peg$c40;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseChained_word();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c5;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c42) {
            s1 = peg$c42;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c45); }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseContents_between_square_brackets() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseContents_between_square_brackets_char();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseContents_between_square_brackets_char();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseContents_between_square_brackets_char() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseToken_square_brackets();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_between_square_brackets();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseToken_square_brackets() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 93) {
        s0 = peg$c38;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }

      return s0;
    }

    function peg$parseToken_square_brackets_escaped() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c49) {
        s1 = peg$c49;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c51();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_between_square_brackets() {
      var s0;

      s0 = peg$parseToken_square_brackets_escaped();
      if (s0 === peg$FAILED) {
        if (input.length > peg$currPos) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }

      return s0;
    }

    function peg$parseGenerative_pure() {
      var s0;

      s0 = peg$parseObject_type();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFunctional_molecule_type();
        if (s0 === peg$FAILED) {
          s0 = peg$parseCovalent_molecule_type();
          if (s0 === peg$FAILED) {
            s0 = peg$parseVariable_type();
            if (s0 === peg$FAILED) {
              s0 = peg$parseText_type();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNumber_type();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseObject_type() {
      var s0;

      s0 = peg$parseObject_type_v1();
      if (s0 === peg$FAILED) {
        s0 = peg$parseObject_type_v2();
      }

      return s0;
    }

    function peg$parseObject_type_v1() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c52;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseObject_properties();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s5 = peg$c38;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c54(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseObject_type_v2() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c55) {
        s2 = peg$c55;
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseObject_properties();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c57;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c54(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseObject_properties() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseObject_property_first();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseObject_property_other();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseObject_property_other();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseObject_property_first() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parse_();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseObject_property_key();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$parse_();
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parse_();
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseGenerative_extended();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseObject_property_other() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseObject_property_first();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseObject_property_key() {
      var s0;

      s0 = peg$parseWord();
      if (s0 === peg$FAILED) {
        s0 = peg$parseText_type();
        if (s0 === peg$FAILED) {
          s0 = peg$parseGenerative_between_square_bracket();
        }
      }

      return s0;
    }

    function peg$parseGenerative_between_square_bracket() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c52;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c53); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseGenerative_extended();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s5 = peg$c38;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c61(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseVariable_type() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c62;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWord();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c64(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCovalent_molecule_type() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseFunction_call_appendix();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseFunctional_atom();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseFunctional_atom();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c65(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunctional_molecule_type() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseFunctional_atom();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseFunctional_atom();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFunctional_atom() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseFunction_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_call_appendix();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c67(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_name() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseFunction_name_by_word();
      if (s1 === peg$FAILED) {
        s1 = peg$parseFunction_name_by_shortcut();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c68(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFunction_name_by_shortcut_without_resolving() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c69;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_name_by_word_without_packing();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_name_by_shortcut() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c69;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_name_by_word_without_packing();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_name_by_word() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseFunction_name_by_word_without_packing();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c73(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFunction_name_by_word_without_packing() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseWord();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseFunction_name_continuation();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseFunction_name_continuation();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c74(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_name_continuation() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseFunction_chainer();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWord();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_chainer() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 32) {
        s0 = peg$c11;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }

      return s0;
    }

    function peg$parseFunction_call_appendix() {
      var s0;

      s0 = peg$parseFunction_call_appendix_for_list_parameter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseFunction_call_appendix_for_empty_parameter();
      }

      return s0;
    }

    function peg$parseFunction_call_appendix_for_list_parameter() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c75;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c76); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parse_();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parse_();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseFunction_parameters();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c57;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c77(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_call_appendix_for_empty_parameter() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c78;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c79); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c80(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseFunction_parameters() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseGenerative_extended();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseFunction_parameter_other();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseFunction_parameter_other();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFunction_parameter_other() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parse_();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseGenerative_extended();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c81(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseExpanded_word_char() {
      var s0;

      if (peg$c82.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }

      return s0;
    }

    function peg$parseExpanded_word_char_with_numbers() {
      var s0;

      if (peg$c84.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }

      return s0;
    }

    function peg$parseWord() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseExpanded_word_char();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseExpanded_word_char_with_numbers();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseExpanded_word_char_with_numbers();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c86();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseNumber_type() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseNumber();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c87(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNumber() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c88;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c90.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c91); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c90.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c91); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c27;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c90.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c91); }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c90.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c91); }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c92(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseText_type() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseText();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c93(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseText() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseToken_double_quote();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseContents_between_double_quotes();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseToken_double_quote();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c94(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseContents_between_double_quotes() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseContents_between_double_quotes_char();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseContents_between_double_quotes_char();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseContents_between_double_quotes_char() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseToken_double_quote();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_between_double_quotes();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseContents_between_double_curly_brackets() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseContents_between_double_curly_brackets_char();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseContents_between_double_curly_brackets_char();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseContents_between_double_curly_brackets_char() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseToken_double_curly_brackets();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseToken_between_double_curly_brackets();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c48(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseToken_double_quote() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c95;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }

      return s0;
    }

    function peg$parseToken_double_quote_escaped() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c97) {
        s1 = peg$c97;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c99();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_between_double_quotes() {
      var s0;

      s0 = peg$parseToken_double_quote_escaped();
      if (s0 === peg$FAILED) {
        if (input.length > peg$currPos) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }

      return s0;
    }

    function peg$parseToken_double_curly_brackets() {
      var s0;

      if (input.substr(peg$currPos, 2) === peg$c23) {
        s0 = peg$c23;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }

      return s0;
    }

    function peg$parseToken_double_curly_brackets_escaped() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c100) {
        s1 = peg$c100;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c102();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseToken_between_double_curly_brackets() {
      var s0;

      s0 = peg$parseToken_double_curly_brackets_escaped();
      if (s0 === peg$FAILED) {
        if (input.length > peg$currPos) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }

      return s0;
    }

    function peg$parseNo_EOL() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parse___();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parse___();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c86();
      }
      s0 = s1;

      return s0;
    }


    // Method for the parser: stringify
    const stringify = JSON.stringify;

    // Method for the parser: simplify_molecule_type
    const minify_location = function(loc) {
      return `${loc.start.line}:${loc.start.column}-${loc.end.line}:${loc.end.column}|${loc.start.offset}-${loc.end.offset}`;
    };

    // Method for the parser: simplify_molecule_type
    const simplify_molecule_type = function(molecule) {
        let formula = "";
        const atoms = molecule.atoms;
        for(let index_atoms=0; index_atoms<atoms.length; index_atoms++) {
          const atom = atoms[index_atoms];
          Append_molekula_formula: {
            formula += atom.name.id;
            formula += "{$";
            formula += index_atoms+1;
            formula += "}";
          }
          let atom_formula = "";
          Set_atom_formula: {
            atom_formula += atom.name.id;
            atom_formula += "{$1}";
            atom.formula = atom_formula;
          }
        }
        if(atoms.length === 1) {
            return Object.assign({ type: atoms[0].type, supertype: "Generative", formula: atoms[0].formula }, atoms[0]);
        }
        add_functional_molecule_mention(formula);
        return Object.assign({ type: molecule.type, supertype: "Generative", formula }, molecule);
    };

    // Method for the parser: function_shortcuts
    const function_shortcuts = {};

    // Method for the parser: declare_function_shortcut
    const declare_function_shortcut = function(shortcut, name) {
      function_shortcuts[shortcut] = name;
      return { [shortcut]: name };
    };

    // Method for the parser: pack_declarations
    const pack_declarations = function(declarations) {
      const packed = {};
      for(let index=0; index<declarations.length; index++) {
        const declaration = declarations[index];
        Object.assign(packed, declaration);
      }
      return packed;
    };

    // Method for the parser: resolve_function_shortcut
    const resolve_function_shortcut = function(ref) {
      if(!(ref in function_shortcuts)) {
        console.log(function_shortcuts)
        throw new Error("Could not resolve function shortcut " + ref + "");
      }
      const id = function_shortcuts[ref];
      return id;
    };

    // Method for the parser: functional_molecule_mentions
    const functional_molecule_mentions = {};
    // Method for the parser: functional_atom_mentions
    const functional_atom_mentions = {};

    // Method for the parser: add_functional_atom_mention
    const add_functional_atom_mention = function(function_name) {
      const { id } = function_name;
      if(!(id in functional_atom_mentions)) {
        functional_atom_mentions[id] = 0;
      }
      functional_atom_mentions[id]++;
      return function_name;
    };

    // Method for the parser: add_functional_molecule_mention
    const add_functional_molecule_mention = function(molecule_formula) {
      if(!(molecule_formula in functional_molecule_mentions)) {
        functional_molecule_mentions[molecule_formula] = 0;
      }
      functional_molecule_mentions[molecule_formula]++;
      return molecule_formula;
    };

    // Method for the parser: get_atom_mentions_sorted
    const get_atom_mentions_sorted = function() {
      const sorted = Object.keys(functional_atom_mentions).sort(function(key1, key2) {
        const val1 = functional_atom_mentions[key1];
        const val2 = functional_atom_mentions[key2];
        if(val1 < val2) {
          return 1;
        } else if(val1 > val2) {
          return -1;
        }
        return 0;
      }).map(function(id) {
        return {[id]:functional_atom_mentions[id]};
      }).reduce(function(output, item, index) {
        const key = Object.keys(item)[0];
        const val = item[key];
        output[key] = "pos=" + (index+1) + " times=" + val + "";
        return output;
      }, {});
      return sorted;
    };

    // Method for the parser: get_molecule_mentions_sorted
    const get_molecule_mentions_sorted = function() {
      const sorted = Object.keys(functional_molecule_mentions).sort(function(key1, key2) {
        const val1 = functional_molecule_mentions[key1];
        const val2 = functional_molecule_mentions[key2];
        if(val1 < val2) {
          return 1;
        } else if(val1 > val2) {
          return -1;
        }
        return 0;
      }).map(function(id) {
        return {[id]:functional_molecule_mentions[id]};
      }).reduce(function(output, item, index) {
        const key = Object.keys(item)[0];
        const val = item[key];
        output[key] = "pos=" + (index+1) + " times=" + val + "";
        return output;
      }, {});
      return sorted;
    };

    // Method for the parser: get_metrics
    const get_metrics = function() {
      return {
        mentions: {
          molecules: get_molecule_mentions_sorted(functional_atom_mentions),
          atoms: get_atom_mentions_sorted(functional_atom_mentions)
        }
      };
    };


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.UPL_parser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(typeof window !== 'undefined' ? window : global);
class UPL_reductor {
  constructor(...args) {
    
  }
  die(...args) {
    console.log(...args);
    process.exit(0);
  }
  trace(method) {
    console.log("[trace][reductor][" + method + "]");
  }
  stringify(ast) {
    return JSON.stringify(ast);
  }
  reduce(ast) {
    return ast;
  }
}
class UPL_formatter extends UPL_reductor {
  constructor(...args) {
    super(...args);
    this.max_expression_chars = 50;
    this.tab_char = "  ";
    this.tab_cursor = 0;
  }
  get_max_line_size() {
    return this.max_expression_chars - (this.tab_cursor*this.tab_char.length);
  }
  should_tab_chained_pipe_appendix(ast, indexes, asb) {
    this.trace("should_tab_chained_pipe_appendix");
    let parent_generative = undefined;
    Get_piped_generative: {
      let val = ast;
      const indexes_for_generative = [].concat(indexes);
      indexes_for_generative.splice(indexes_for_generative.length - 2);
      for(let index=0; index<indexes_for_generative.length; index++) {
        const key = indexes_for_generative[index];
        val = val[key];
      }
      parent_generative = val;
    }
    const how_many_appendixes_has_parent = parent_generative.extended_by.length;
    const current_position = indexes[indexes.length-1];
    const is_first_pipe = current_position === 0 ? true : (parent_generative.extended_by[current_position-1].type !== "Pipe_appendix");
    const is_generative_0 = parent_generative.script === 1;
    if(is_first_pipe && is_generative_0) {
      return false;
    }
    if(how_many_appendixes_has_parent > 1) {
      return true;
    }
    return false;
  }
  trace(method) {
    console.log("[trace][formatter][" + method + "]");
  }
  tab(mov = 0) {
    if (mov) {
      this.tab_cursor += mov;
    }
    return this.tab_char.repeat(this.tab_cursor);
  }
  format(ast) {
    this.trace("format");
    return this.format_recursively(ast, [], ast).trim();
  }
  format_Language(ast, indexes, asb) {
    this.trace("format_Language");
    let code = "";
    code += this.format_recursively(ast, [].concat(indexes).concat(["header"]), asb.header);
    code += this.format_recursively(ast, [].concat(indexes).concat(["body"]), asb.body);
    // code += this.format_recursively(ast, [].concat(indexes).concat(["footer"]), );
    return code;
  }
  format_Preblock(ast, indexes, asb) {
    this.trace("format_Preblock");
    const declarations = asb.declarations;
    let code = "";
    for (let prop in declarations) {
      const val = declarations[prop];
      code += this.tab(0);
      code += "#";
      code += prop;
      code += "=";
      code += val;
      code += "\n";
    }
    return code;
  }
  format_object_key(ast, indexes, key) {
    this.trace("format_object_key");
    if(typeof key === "string") {
      return key;
    } else {
      return this.format_recursively(ast, indexes, key);
    }
  }
  format_Object(ast, indexes, asb) {
    this.trace("format_Object");
    const props = asb.properties;
    let code = "";
    let must_tab = false;
    if (asb.script > this.get_max_line_size()) {
      must_tab = true;
    }
    code += "object{";
    if(must_tab) {
      this.tab(1);
    }
    if (props && props.length) {
      for (let index = 0; index < props.length; index++) {
        const prop = props[index];
        const { key, val } = prop;
        if (must_tab) {
          code += "\n";
          code += this.tab(0);
        } else {
          code += " ";
        }
        code += this.format_object_key(ast, [].concat(indexes).concat(["properties", index, "key"]), key);
        code += "=";
        code += this.format_recursively(ast, [].concat(indexes).concat(["properties", index, "val"]), val);
      }
    }
    if (must_tab) {
      code += "\n";
      code += this.tab(-1);
    } else {
      code += " ";
    }
    code += "}";
    return code;
  }
  format_Function_call_appendix_for_text_parameter(ast, indexes, asb) {
    this.trace("format_Function_call_appendix_for_text_parameter");
    let code = "";
    code += "{{";
    code += asb.text;
    code += "}}";
    return code;
  }
  format_Function_call_appendix_for_empty_parameter(ast, indexes, asb) {
    this.trace("format_Function_call_appendix_for_empty_parameter");
    return "!";
  }
  format_Function_call_appendix_for_list_parameter(ast, indexes, asb) {
    this.trace("format_Function_call_appendix_for_list_parameter");
    let must_tab = false;
    if (asb.script > this.get_max_line_size()) {
      must_tab = true;
    }
    let code = "";
    Intro: {
      code += "{";
    }
    Body: {
      const list = asb.list;
      if (list.length === 0) {
        break Body;
      }
      if (must_tab) {
        this.tab(1);
      }
      for (let index_list = 0; index_list < list.length; index_list++) {
        const item = list[index_list];
        if (must_tab) {
          code += "\n";
          code += this.tab(0);
        } else {
          code += " ";
        }
        code += this.format_recursively(ast, [].concat(indexes).concat(["list", index_list]), item);
      }
      if (must_tab) {
        code += "\n";
        this.tab(-1);
        code += this.tab(0);
      } else {
        code += " ";
      }
    }
    Bye: {
      code += "}";
    }
    return code;
  }
  format_Functional_atom(ast, indexes, asb) {
    this.trace("format_Functional_atom");
    let code = "";
    Set_name: {
      if (asb.name.aliased) {
        code += "#";
        code += asb.name.aliased;
      } else {
        code += asb.name.id;
      }
    }
    Set_parameters: {
      if(asb.parameters) {
        code += this.format_recursively(ast, [].concat(indexes).concat(["parameters"]), asb.parameters);
      }
    }
    return code;
  }
  format_Functional_molecule(ast, indexes, asb) {
    this.trace("format_Functional_molecule");
    let code = "";
    const atoms = asb.atoms;
    code += this.format_recursively(ast, [].concat(indexes).concat(["atoms"]), atoms, "").join("");
    return code;
  }
  format_Number(ast, indexes, asb) {
    this.trace("format_Number");
    return asb.value;
  }
  format_Text(ast, indexes, asb) {
    this.trace("format_Text");
    return JSON.stringify(asb.contents);
  }
  format_Variable(ast, indexes, asb) {
    this.trace("format_Variable");
    return "@" + ((asb.name === null) ? "" : asb.name);
  }
  format_Access_by_dot_appendix(ast, indexes, asb) {
    this.trace("format_Access_by_dot_appendix");
    let code = "";
    code += ".";
    code += asb.access;
    return code;
  }
  format_Access_by_accessor_appendix(ast, indexes, asb) {
    this.trace("format_Access_by_accessor_appendix");
    let code = "";
    code += "[";
    code += this.format_recursively(ast, [].concat(indexes).concat(["access"]), asb.access);
    code += "]";
    return code;
  }
  format_Call_appendix(ast, indexes, asb) {
    this.trace("format_Call_appendix");
    let code = "";
    code += "{";
    if (asb.script > this.get_max_line_size()) {
      code += "\n";
      code += this.tab(1);
      code += this.format_recursively(ast, [].concat(indexes).concat(["parameters"]), asb.parameters);
      code += "\n";
      code += this.tab(-1);
    } else {
      code += " ";
      code += this.format_recursively(ast, [].concat(indexes).concat(["parameters"]), asb.parameters);
      code += " ";
    }
    code += "}";
    return code;
  }
  format_Pipe_appendix(ast, indexes, asb) {
    this.trace("format_Pipe_appendix");
    const { operator, pipe } = asb;
    let must_tab = this.should_tab_chained_pipe_appendix(ast, indexes, asb);
    let code = "";
    this.tab(1);
    if(must_tab) {
      code += "\n";
      code += this.tab(0);
    } else {
      code += " ";
    }
    code += operator;
    code += " ";
    code += this.format_recursively(ast, [].concat(indexes).concat(["pipe"]), pipe);
    this.tab(-1);
    return code;
  }
  format_Covalent_molecule_type(ast, indexes, asb) {
    this.trace("format_Covalent_molecule_type");
    let code = "";
    code += this.format_recursively(ast, [].concat(indexes).concat(["base"]), asb.base);
    code += this.format_recursively(ast, [].concat(indexes).concat(["atoms"]), asb.atoms, "").join("");
    return code;
  }
  format_recursively(ast, indexes, asb, list_separator = "\n") {
    this.trace("format_recursively");
    if(typeof indexes === "undefined" || typeof asb === "undefined") {
      throw new Error("The method format_recursively requires 3 parameters");
    }
    if (typeof asb === "object") {
      if (Array.isArray(asb)) {
        if (list_separator) {
          let code = "";
          for (let index_item = 0; index_item < asb.length; index_item++) {
            const item = asb[index_item];
            code += list_separator;
            code += this.format_recursively(ast, [].concat(indexes).concat([index_item]), item);
          }
          return code;
        } else {
          let block = [];
          for (let index_item = 0; index_item < asb.length; index_item++) {
            const item = asb[index_item];
            const subblock = this.format_recursively(ast, [].concat(indexes).concat([index_item]), item);
            block.push(subblock);
          }
          return block;
        }
      } else if (typeof asb.type === "string") {
        const method_name = "format_" + asb.type;
        if (method_name in this) {
          let code = "";
          code += this[method_name](ast, indexes, asb);
          if (asb.supertype === "Generative") {
            if (asb.extended_by) {
              code += this.format_recursively(ast, [].concat(indexes).concat(["extended_by"]), asb.extended_by, "").join("");
            }
          }
          return code;
        } else {
          // Do not throw yet...
          // throw new Error("Syntax format method not identified: format_" + asb.type + "")
        }
      } else {
        throw new Error("The method format_recursively can only work with objects with type or arrays on index " + indexes.join("/") + " in the json abstract syntax tree");
      }
    } else {
      throw new Error("The method format_recursively can only format objects, not strings on index " + indexes.join("/") + " in the json abstract syntax tree");
    }
  }
}
class UPL_transpiler_tag_methods {
  constructor() {

  }
  tag_recursively(ast, indexes, asb, result = {}) {
    if (Array.isArray(asb)) {
      const tagging = [];
      for (let index_item = 0; index_item < asb.length; index_item++) {
        const asb_item = asb[index_item];
        const tagged_item = this.tag_recursively(ast, indexes.concat([index_item]), asb[index_item], result);
        tagging.push(tagged_item);
      }
      return tagging;
    } else if (typeof asb === "object") {
      const asb_type = asb.type;
      if (typeof asb_type !== "string") {
        throw new Error("Method tag_recursively can only work with objects that specify type property");
      }
      const asb_tagger = "tag_" + asb_type;
      if (!(asb_tagger in this)) {
        throw new Error("Method " + asb_tagger + " is not known by the tagr");
      }
      return this[asb_tagger](ast, indexes, asb, result);
    }
    throw new Error("Method tag_recursively can only work with objects");
  }
  tag_Language(ast, indexes, asb) {
    this.trace("tag_Language");
    const interception = this.intercept_tagging(ast, indexes, asb, "Language");
    if (interception) {
      return interception;
    }
    this.tag_recursively(ast, indexes.concat(["body"]), asb.body);
    return asb;
  }
  tag_Functional_molecule(ast, indexes, asb) {
    this.trace("tag_Functional_molecule");
    const interception = this.intercept_tagging(ast, indexes, asb, "Functional_molecule");
    if (interception) {
      return interception;
    }
    this.tag_recursively(ast, indexes.concat(["atoms"]), asb.atoms);
    return asb;
  }
  tag_Functional_atom(ast, indexes, asb) {
    this.trace("tag_Functional_atom");
    const interception = this.intercept_tagging(ast, indexes, asb, "Functional_atom");
    if (interception) {
      return interception;
    }
    this.tag_recursively(ast, indexes.concat(["name"]), asb.name);
    this.tag_recursively(ast, indexes.concat(["parameters"]), asb.parameters);
    return asb;
  }
  tag_Function_name_by_word(ast, indexes, asb) {
    this.trace("tag_Function_name_by_word");
    const interception = this.intercept_tagging(ast, indexes, asb, "Function_name_by_word");
    if (interception) {
      return interception;
    }
    return asb;
  }
  tag_Function_call_appendix_for_list_parameter(ast, indexes, asb) {
    this.trace("tag_Function_call_appendix_for_list_parameter");
    const interception = this.intercept_tagging(ast, indexes, asb, "Function_call_appendix_for_list_parameter");
    if (interception) {
      return interception;
    }
    this.tag_recursively(ast, indexes.concat(["list"]), asb.list, "Function_call_appendix_for_list_parameter");
    return asb;
  }
  tag_Variable(ast, indexes, asb) {
    this.trace("tag_Variable");
    const interception = this.intercept_tagging(ast, indexes, asb, "Variable");
    if (interception) {
      return interception;
    }
    return asb;
  }
  tag_Number(ast, indexes, asb) {
    this.trace("tag_Number");
    const interception = this.intercept_tagging(ast, indexes, asb, "Number");
    if (interception) {
      return interception;
    }
    return asb;
  }
  tag_Text(ast, indexes, asb) {
    this.trace("tag_Text");
    const interception = this.intercept_tagging(ast, indexes, asb, "Text");
    if (interception) {
      return interception;
    }
    return asb;
  }
  commit_syntax_tag(possible_syntax, ast, indexes, asb) {
    this.trace("commit_syntax_tag");
    const { tagger } = possible_syntax;
    if(typeof tagger === "function") {
      const extra_tags = tagger.call(this, ast, indexes, asb);
      if(typeof extra_tags === "object" && extra_tags !== null) {
        Object.assign(asb, extra_tags);
      }
    }
    return undefined;
  }
  intercept_tagging(ast, indexes, asb, syntax_type) {
    this.trace("intercept_tagging");
    if (this.allowed_molecule_syntaxes.indexOf(syntax_type) !== -1) {
      return this.intercept_tagging_as_molecule(ast, indexes, asb);
    }
    return undefined;
  }
  intercept_tagging_as_molecule(ast, indexes, asb) {
    this.trace("intercept_tagging_as_molecule");
    const possible_syntaxes = this.molecule_syntaxes;
    for (let index_possible = 0; index_possible < possible_syntaxes.length; index_possible++) {
      const possible_syntax = possible_syntaxes[index_possible];
      const is_matched = this.is_matched_syntax(possible_syntax, ast, indexes, asb);
      if (is_matched) {
        return this.commit_syntax_tag(possible_syntax, ast, indexes, asb);
      }
    }
  }
}

class UPL_transpiler_check_methods {
  constructor() {

  }
  molecule_syntaxes = [];
  allowed_molecule_syntaxes = [
    "Functional_molecule",
    "Covalent_molecule"
  ];
  intercept_checking(ast, indexes, asb, syntax_type) {
    this.trace("intercept_checking");
    if (this.allowed_molecule_syntaxes.indexOf(syntax_type) !== -1) {
      return this.intercept_checking_as_molecule(ast, indexes, asb);
    }
    return undefined;
  }
  commit_syntax_check(possible_syntax, ast, indexes, asb) {
    this.trace("commit_syntax_check");
    const { checker } = possible_syntax;
    if(typeof checker === "function") {
      return checker.call(this, ast, indexes, asb);
    }
    return undefined;
  }
  intercept_checking_as_molecule(ast, indexes, asb) {
    this.trace("intercept_checking_as_molecule");
    const possible_syntaxes = this.molecule_syntaxes;
    for (let index_possible = 0; index_possible < possible_syntaxes.length; index_possible++) {
      const possible_syntax = possible_syntaxes[index_possible];
      const is_matched = this.is_matched_syntax(possible_syntax, ast, indexes, asb);
      if (is_matched) {
        return this.commit_syntax_check(possible_syntax, ast, indexes, asb);
      }
    }
  }
  is_matched_syntax(possible_syntax, ast, indexes, asb) {
    this.trace("is_matched_syntax");
    const { formula: possible_formula, matcher: possible_matcher } = possible_syntax;
    let is_formula_match = true;
    Formula_matching: {
      if (typeof possible_formula === "string") {
        const formula_expanded = possible_formula.replace(/@/g, "\\\{\\\$[0-9]+\}");
        const formula_regex = new RegExp(formula_expanded);
        is_formula_match = formula_regex.test(asb.formula);
      } else {
        is_formula_match = possible_formula;
      }
      if (!is_formula_match) {
        return false;
      }
    }
    let is_matcher_match = false;
    Matcher_matching: {
      if (typeof matcher === "function") {
        is_matcher_match = possible_matcher.call(this, ast, indexes, asb);
      } else {
        is_matcher_match = possible_matcher;
      }
    }
    if (!is_matcher_match) {
      return false;
    }
    return true;
  }
  is_one_variable_in_group_only(asb) {
    if(Array.isArray(asb)) {
      if(asb.length !== 1) {
        return {
          rule: "is_one_variable_in_group_only",
          origin: "it complains because it only admits groups of 1 element"
        };
      }
      if(asb[0].type !== "Variable") {
        return {
          rule: "is_one_variable_in_group_only",
          origin: "it complains because it only admits groups of 1 element that is a variable name"
        };
      }
      return true;
    }
    return {
      rule: "is_one_variable_in_group_only",
      origin: "it complains because it does not recognize the structure provided"
    };
  }
  is_one_generative_in_group_only(asb) {
    if(Array.isArray(asb)) {
      if(asb.length !== 1) {
        return {
          rule: "is_one_generative_in_group_only",
          origin: "it complains because it only admits groups of 1 element"
        };
      }
      if(asb[0].is_sentence === true) {
        return {
          rule: "is_one_generative_in_group_only",
          origin: "it complains because it only admits groups of 1 element that is not a sentence"
        };
      }
      if(asb[0].supertype !== "Generative") {
        return {
          rule: "is_one_generative_in_group_only",
          origin: "it complains because it only admits groups of 1 element that is a generative"
        };
      }
      return true;
    }
    return {
      rule: "is_one_generative_in_group_only",
      origin: "it complains because it does not recognize the structure provided"
    };
  }
  check_Language(ast, indexes, asb) {
    this.trace("check_Language");
    const interception = this.intercept_checking(ast, indexes, asb, "Language");
    if (interception) {
      return interception;
    }
    this.check_recursively(ast, indexes.concat(["body"]), asb.body);
    return true;
  }
  check_Functional_molecule(ast, indexes, asb) {
    this.trace("check_Functional_molecule");
    const interception = this.intercept_checking(ast, indexes, asb, "Functional_molecule");
    if (interception) {
      return interception;
    }
    this.check_recursively(ast, indexes.concat(["atoms"]), asb.atoms);
    return true;
  }
  check_Functional_atom(ast, indexes, asb) {
    this.trace("check_Functional_atom");
    const interception = this.intercept_checking(ast, indexes, asb, "Functional_atom");
    if (interception) {
      return interception;
    }
    this.check_recursively(ast, indexes.concat(["name"]), asb.name);
    this.check_recursively(ast, indexes.concat(["parameters"]), asb.parameters);
    return true;
  }
  check_Function_name_by_word(ast, indexes, asb) {
    this.trace("check_Function_name_by_word");
    const interception = this.intercept_checking(ast, indexes, asb, "Function_name_by_word");
    if (interception) {
      return interception;
    }
    return true;
  }
  check_Function_call_appendix_for_list_parameter(ast, indexes, asb) {
    this.trace("check_Function_call_appendix_for_list_parameter");
    const interception = this.intercept_checking(ast, indexes, asb, "Function_call_appendix_for_list_parameter");
    if (interception) {
      return interception;
    }
    this.check_recursively(ast, indexes.concat(["list"]), asb.list, "Function_call_appendix_for_list_parameter");
    return true;
  }
  check_Variable(ast, indexes, asb) {
    this.trace("check_Variable");
    const interception = this.intercept_checking(ast, indexes, asb, "Variable");
    if (interception) {
      return interception;
    }
    return true;
  }
  check_Number(ast, indexes, asb) {
    this.trace("check_Number");
    const interception = this.intercept_checking(ast, indexes, asb, "Number");
    if (interception) {
      return interception;
    }
    return true;
  }
  check_Text(ast, indexes, asb) {
    this.trace("check_Text");
    const interception = this.intercept_checking(ast, indexes, asb, "Text");
    if (interception) {
      return interception;
    }
    return true;
  }
  check_recursively(ast, indexes, asb, result = {}) {
    if (Array.isArray(asb)) {
      const checking = [];
      for (let index_item = 0; index_item < asb.length; index_item++) {
        const asb_item = asb[index_item];
        const checkd_item = this.check_recursively(ast, indexes.concat([index_item]), asb[index_item], result);
        checking.push(checkd_item);
      }
      return checking.join("\n");
    } else if (typeof asb === "object") {
      const asb_type = asb.type;
      if (typeof asb_type !== "string") {
        throw new Error("Method check_recursively can only work with objects that specify type property");
      }
      const asb_checkr = "check_" + asb_type;
      if (!(asb_checkr in this)) {
        throw new Error("Method " + asb_checkr + " is not known by the checkr");
      }
      return this[asb_checkr](ast, indexes, asb, result);
    }
    throw new Error("Method check_recursively can only work with objects");
  }
}

class UPL_transpiler_transpile_methods {
  intercept_transpilation(ast, indexes, asb, syntax_type) {
    this.trace("intercept_transpilation");
    console.log("Interceptable type: " + syntax_type);
    return undefined;
  }
  transpile_Language(ast, indexes, asb) {
    this.trace("transpile_Language");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Language");
    if (interception) {
      return interception;
    }
    let output = "";
    output += this.transpile_recursively(ast, indexes.concat(["body"]), asb.body);
    return output;
  }
  transpile_Functional_molecule(ast, indexes, asb) {
    this.trace("transpile_Functional_molecule");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Functional_molecule");
    if (interception) {
      return interception;
    }
    let output = "";
    output += this.transpile_recursively(ast, indexes.concat(["atoms"]), asb.atoms).join(".");
    return output;
  }
  transpile_Functional_atom(ast, indexes, asb) {
    this.trace("transpile_Functional_atom");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Functional_atom");
    if (interception) {
      return interception;
    }
    let output = "";
    output += this.transpile_recursively(ast, indexes.concat(["name"]), asb.name);
    output += this.transpile_recursively(ast, indexes.concat(["parameters"]), asb.parameters);
    return output;
  }
  transpile_Function_name_by_word(ast, indexes, asb) {
    this.trace("transpile_Function_name_by_word");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Function_name_by_word");
    if (interception) {
      return interception;
    }
    let output = "";
    output += asb.id.replace(/ /g, "/");
    return output;
  }
  transpile_Function_call_appendix_for_list_parameter(ast, indexes, asb) {
    this.trace("transpile_Function_call_appendix_for_list_parameter");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Function_call_appendix_for_list_parameter");
    if (interception) {
      return interception;
    }
    let output = "";
    output += "(";
    output += this.transpile_recursively(ast, indexes.concat(["list"]), asb.list).join(", ");
    output += ")";
    return output;
  }
  transpile_Variable(ast, indexes, asb) {
    this.trace("transpile_Variable");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Variable");
    if (interception) {
      return interception;
    }
    let output = "";
    output += asb.name;
    return output;
  }
  transpile_Number(ast, indexes, asb) {
    this.trace("transpile_Number");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Number");
    if (interception) {
      return interception;
    }
    let output = "";
    output += asb.value;
    return output;
  }
  transpile_Text(ast, indexes, asb) {
    this.trace("transpile_Text");
    const interception = this.intercept_transpilation(ast, indexes, asb, "Text");
    if (interception) {
      return interception;
    }
    let output = "";
    output += JSON.stringify(asb.contents);
    return output;
  }
  transpile_recursively(ast, indexes, asb, result = {}) {
    if (Array.isArray(asb)) {
      const transpilation = [];
      for (let index_item = 0; index_item < asb.length; index_item++) {
        const asb_item = asb[index_item];
        const transpiled_item = this.transpile_recursively(ast, indexes.concat([index_item]), asb[index_item], result);
        transpilation.push(transpiled_item);
      }
      return transpilation;
    } else if (typeof asb === "object") {
      const asb_type = asb.type;
      if (typeof asb_type !== "string") {
        throw new Error("Method transpile_recursively can only work with objects that specify type property");
      }
      const asb_transpiler = "transpile_" + asb_type;
      if (!(asb_transpiler in this)) {
        throw new Error("Method " + asb_transpiler + " is not known by the transpiler");
      }
      return this[asb_transpiler](ast, indexes, asb, result);
    }
    throw new Error("Method transpile_recursively can only work with objects");
  }
}

class Create_as_syntax_for_js {
  type = "Molecule";
  formula = "create( variable)?{@}(as{@})?"
  checker() {
    console.log("Checker triggered!");
  }
  tagger() {
    console.log("Tagger triggered!");
  }
  transpiler() {
    console.log("Transpiler triggered!");
  }
};

class UPL_transpiler extends UPL_reductor {
  static language = "javascript";
  static version = "1.0.0";
  syntaxes = [
    new Create_as_syntax_for_js(),
  ];
  trace(method) {
    console.log("[trace][transpiler][" + method + "]");
  }
  compact_syntaxes() {
    this.molecule_syntaxes = [];
    for (let index_syntax = 0; index_syntax < this.syntaxes.length; index_syntax++) {
      const syntax = this.syntaxes[index_syntax];
      const { type: syntax_type } = syntax;
      if (syntax_type === "Molecules") {
        this.molecule_syntaxes.push(syntax);
      }
    }
  }
  getAllMethodNames(obj, depth = Infinity) {
    const methods = new Set();
    while (depth-- && obj) {
      for (const key of Reflect.ownKeys(obj)) {
        methods.add(key)
      }
      obj = Reflect.getPrototypeOf(obj);
    }
    return [...methods].filter(m => [
      "constructor",
      "__proto__",
      "__defineGetter__",
      "__defineSetter__",
      "__lookupGetter__",
      "__lookupSetter__",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toString",
      "toLocaleString",
      "valueOf",
    ].indexOf(m) === -1);
  }
  inherit_methods_from(obj) {
    this.trace("inherit_methods_from");
    const methods = this.getAllMethodNames(obj);
    for (let method_index in methods) {
      const method_id = methods[method_index];
      if (method_id in this) {
        throw new Error("Cannot overwrite method " + method_id + " by inherit_methods_froms method");
      }
      const val = obj[method_id];
      if (typeof val === "function") {
        this[method_id] = val.bind(this);
      } else {
        this[method_id] = val;
      }
    }
  }
  constructor(...args) {
    super(...args);
    this.inherit_methods_from(new UPL_transpiler_transpile_methods());
    this.inherit_methods_from(new UPL_transpiler_check_methods());
    this.inherit_methods_from(new UPL_transpiler_tag_methods());
    this.Compilation_error = class extends Error {
      constructor(message) {
        super("");
        this.name = "Compilation_error";
        this.message = JSON.stringify(message, null, 2);
      }
    };
  }
  transpile(ast_input) {
    this.trace("transpile");
    this.compact_syntaxes();
    const ast_origin = JSON.parse(JSON.stringify(ast_input));
    const tagged = this.tag_recursively(ast_origin, [], ast_origin);
    const checked = this.check_recursively(tagged, [], tagged);
    const transpiled = this.transpile_recursively(tagged, [], tagged);
    return { tagged, transpiled };
  }
}
const UPL_parser = (typeof window !== "undefined") ? window.UPL_parser : global.UPL_parser;
const UPL = class {
  static classes = {
    parser: UPL_parser,
    formatter: UPL_formatter,
    transpiler: UPL_transpiler
  };
  static default_parse_options = {
    trace: true,
    mode: "ast", // or "transpile" or "format"
  };
  static parse(text, options = this.default_parse_options) {
    if(options.mode === "ast") {
      return this.parse_to_ast(text, options);
    } else if(options.mode === "format") {
      return this.format(text, options);
    } else if(options.mode === "transpile") {
      throw new Error("Mode of parsing transpile is not supported through static method, as upl is unopinionated on interpretation. Create a transpiler instead, specifying all the known syntaxes, and use the dynamic method.");
    }
    throw new Error("Mode of parsing not identified: " + options.mode + "");
  }
  static parse_to_ast(...args) {
    return this.classes.parser.parse(...args);
  };
  static format(text, options = this.default_parse_options) {
    const ast = this.parse_to_ast(text, options);
    const formatter = new this.classes.formatter();
    return formatter.format(ast);
  }
  static create(...args) {
    return new this(...args);
  }
  static createTranspiler(known_syntaxes = []) {
    const clazz = this;
    const upl_instance = new clazz();
    upl_instance.classes.transpiler = class extends UPL_transpiler {
      syntaxes = known_syntaxes;
    };
    return upl_instance;
  }
  constructor(classes = {}) {
    this.classes = {};
    Object.assign(this.classes, this.constructor.classes, classes);
  }
  parse(text, options = this.default_parse_options) {
    if(options.mode === "ast") {
      return this.parse_to_ast(text, options);
    } else if(options.mode === "format") {
      return this.format(text, options);
    } else if(options.mode === "transpile") {
      return this.transpile(text, options);
    }
    throw new Error("Mode of parsing not identified: " + options.mode + "");
  }
  parse_to_ast = this.constructor.parse_to_ast;
  format=this.constructor.format;
  transpile(text, options = this.default_parse_options) {
    const ast = this.parse_to_ast(text, options);
    const transpiler = new this.classes.transpiler();
    return transpiler.transpile(ast);
  }
}
UPL.default = UPL;
if(typeof window !== "undefined") {
  window.UPL = UPL;
}
if(typeof global !== "undefined") {
  global.UPL = UPL;
}
if(typeof module !== "undefined") {
  module.exports = UPL;
}
